#!/usr/bin/env python3
"""
QSVM Qiskit Tutorial for Google Colab
======================================

This notebook shows how to:
1. Load the QASM file generated by Rust
2. Visualize the quantum circuit
3. Simulate on IBM Quantum simulator
4. (Optional) Run on real IBM quantum hardware

Copy this entire file into Google Colab and run!
"""

# =============================================================================
# STEP 1: Install required packages (run this cell first in Colab)
# =============================================================================
# !pip install qiskit qiskit-aer qiskit-ibm-runtime qiskit-visualization

# =============================================================================
# STEP 2: Import libraries
# =============================================================================
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
import numpy as np

print("âœ… Libraries imported successfully!")

# =============================================================================
# STEP 3: Define the QASM circuit (copy from feature_map.qasm)
# =============================================================================
# This is the ZZ Feature Map generated by our Rust QSVM
# You can also load from file: QuantumCircuit.from_qasm_file("feature_map.qasm")

qasm_code = """
OPENQASM 2.0;
include "qelib1.inc";

// 4 qubits for 4 features
qreg q[4];
creg c[4];

// Layer 1: Hadamard gates - create superposition
h q[0];
h q[1];
h q[2];
h q[3];

// Layer 2: RZ rotations - encode features into phases
// Replace these values with your actual data!
rz(0.123456) q[0];
rz(0.234567) q[1];
rz(0.345678) q[2];
rz(0.456789) q[3];

// Layer 3: CNOT entanglement
cx q[0],q[1];
cx q[1],q[2];
cx q[2],q[3];

// Layer 4: Second RZ rotation
rz(0.246912) q[0];
rz(0.469134) q[1];
rz(0.691356) q[2];
rz(0.913578) q[3];

// Add measurements (uncomment to measure)
measure q[0] -> c[0];
measure q[1] -> c[1];
measure q[2] -> c[2];
measure q[3] -> c[3];
"""

# Create circuit from QASM
circuit = QuantumCircuit.from_qasm_str(qasm_code)

print(f"âœ… Circuit created with {circuit.num_qubits} qubits")

# =============================================================================
# STEP 4: Visualize the circuit
# =============================================================================
print("\nðŸ“Š Circuit Diagram:")
print(circuit.draw(output='text'))

# In Colab, you can also do:
# circuit.draw(output='mpl')  # For matplotlib figure

# =============================================================================
# STEP 5: Simulate the circuit
# =============================================================================
print("\nðŸ”¬ Running simulation...")

# Use the Aer simulator
simulator = AerSimulator()

# Run the circuit 1024 times
job = simulator.run(circuit, shots=1024)
result = job.result()
counts = result.get_counts()

print("\nðŸ“ˆ Measurement results (top 5):")
sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)
for state, count in sorted_counts[:5]:
    probability = count / 1024 * 100
    print(f"  |{state}âŸ©: {count} ({probability:.1f}%)")

# =============================================================================
# STEP 6: Get the statevector (without measurement)
# =============================================================================
print("\nðŸŒŠ Getting statevector (quantum state amplitudes)...")

# Create circuit without measurements for statevector
circuit_no_measure = QuantumCircuit.from_qasm_str(qasm_code.replace("measure", "// measure"))
circuit_no_measure.save_statevector()

job = simulator.run(circuit_no_measure)
result = job.result()
statevector = result.get_statevector()

print("\nFirst 8 amplitudes:")
for i in range(8):
    amp = statevector[i]
    print(f"  |{i:04b}âŸ©: {amp:.4f} (prob: {abs(amp)**2:.4f})")

# =============================================================================
# STEP 7: Compute Quantum Kernel (example)
# =============================================================================
def create_feature_map_circuit(features):
    """Create ZZ feature map circuit for given features."""
    n = len(features)
    qc = QuantumCircuit(n)
    
    # Layer 1: Hadamard
    for i in range(n):
        qc.h(i)
    
    # Layer 2: RZ(feature)
    for i, f in enumerate(features):
        qc.rz(f, i)
    
    # Layer 3: CNOT entanglement
    for i in range(n-1):
        qc.cx(i, i+1)
    
    # Layer 4: RZ(2*feature)
    for i, f in enumerate(features):
        qc.rz(2*f, i)
    
    return qc

def compute_kernel(x1, x2):
    """Compute quantum kernel between two feature vectors."""
    # Create circuits
    qc1 = create_feature_map_circuit(x1)
    qc2 = create_feature_map_circuit(x2)
    
    # Get statevectors
    qc1.save_statevector()
    qc2.save_statevector()
    
    sv1 = AerSimulator().run(qc1).result().get_statevector()
    sv2 = AerSimulator().run(qc2).result().get_statevector()
    
    # Kernel = |<phi1|phi2>|^2
    inner_product = np.vdot(sv1, sv2)  # conjugate of sv1 dot sv2
    kernel = abs(inner_product) ** 2
    
    return kernel

# Example
print("\nðŸ§® Computing quantum kernel...")
x1 = [0.1, 0.2, 0.3, 0.4]
x2 = [0.1, 0.2, 0.3, 0.4]  # Same as x1
x3 = [0.9, 0.8, 0.7, 0.6]  # Different

k_same = compute_kernel(x1, x2)
k_diff = compute_kernel(x1, x3)

print(f"  K(x1, x1) = {k_same:.4f}  (should be ~1.0 for identical)")
print(f"  K(x1, x3) = {k_diff:.4f}  (should be < 1.0 for different)")

# =============================================================================
# STEP 8: (OPTIONAL) Run on Real IBM Quantum Hardware
# =============================================================================
"""
To run on real quantum hardware:

1. Create an IBM Quantum account: https://quantum.ibm.com/
2. Get your API token from the dashboard
3. Uncomment and run the code below:

from qiskit_ibm_runtime import QiskitRuntimeService

# Save your credentials (only need to do once)
# QiskitRuntimeService.save_account(channel="ibm_quantum", token="YOUR_API_TOKEN")

# Connect to IBM Quantum
service = QiskitRuntimeService()

# Get a backend (real quantum computer)
backend = service.least_busy(simulator=False)
print(f"Running on: {backend.name}")

# Run the circuit
job = backend.run(circuit, shots=1024)
result = job.result()
counts = result.get_counts()

print("Results from REAL quantum computer:")
print(counts)
"""

print("\nâœ¨ Tutorial complete!")
print("\nNext steps:")
print("1. Replace the QASM with your actual feature_map.qasm")
print("2. Try different feature values")
print("3. (Optional) Run on real IBM quantum hardware")
