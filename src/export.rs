//! Export Module for QSVM
//!
//! This module provides functionality to export:
//! 1. Quantum circuits in OpenQASM 2.0 format (for Qiskit/Cirq)
//! 2. Trained model parameters as JSON
//!
//! ## Why Export?
//!
//! - **QASM Export**: Test your circuits on real quantum hardware (IBM, Google)
//! - **Model Export**: Save trained model for later use without retraining

use crate::qsvm::QSVM;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::Write;
use std::path::Path;

/// Generates OpenQASM 2.0 code for the ZZ Feature Map circuit.
///
/// # What is OpenQASM?
/// OpenQASM (Open Quantum Assembly Language) is a standard format for
/// describing quantum circuits. It's supported by:
/// - IBM Qiskit
/// - Google Cirq
/// - Amazon Braket
/// - Many other quantum frameworks
///
/// # Arguments
/// * `data` - Feature vector to encode (length = number of qubits)
///
/// # Returns
/// String containing valid OpenQASM 2.0 code
///
/// # Example Output
/// ```qasm
/// OPENQASM 2.0;
/// include "qelib1.inc";
/// qreg q[4];
/// creg c[4];
/// h q[0];
/// h q[1];
/// h q[2];
/// h q[3];
/// rz(0.5) q[0];
/// rz(1.0) q[1];
/// ...
/// ```
pub fn generate_qasm(data: &[f64]) -> String {
    let n_qubits = data.len();
    let mut qasm = String::new();

    // =========================================================================
    // Header: QASM version and standard library
    // =========================================================================
    qasm.push_str("// OpenQASM 2.0 - ZZ Feature Map for QSVM\n");
    qasm.push_str("// Generated by quantum-simulation-qsvm (Rust)\n\n");
    qasm.push_str("OPENQASM 2.0;\n");
    qasm.push_str("include \"qelib1.inc\";\n\n");

    // =========================================================================
    // Register declarations
    // =========================================================================
    // qreg = quantum register (qubits)
    // creg = classical register (for measurements)
    qasm.push_str(&format!(
        "// {} qubits for {} features\n",
        n_qubits, n_qubits
    ));
    qasm.push_str(&format!("qreg q[{}];\n", n_qubits));
    qasm.push_str(&format!("creg c[{}];\n\n", n_qubits));

    // =========================================================================
    // Layer 1: Hadamard gates (create superposition)
    // =========================================================================
    qasm.push_str("// Layer 1: Hadamard gates - create superposition |+⟩\n");
    for i in 0..n_qubits {
        qasm.push_str(&format!("h q[{}];\n", i));
    }
    qasm.push_str("\n");

    // =========================================================================
    // Layer 2: RZ rotations (encode data into phases)
    // =========================================================================
    qasm.push_str("// Layer 2: RZ rotations - encode features into phases\n");
    for (i, &x) in data.iter().enumerate() {
        // RZ(θ) applies phase rotation by angle θ
        qasm.push_str(&format!("rz({:.6}) q[{}];\n", x, i));
    }
    qasm.push_str("\n");

    // =========================================================================
    // Layer 3: CNOT entanglement (create correlations between qubits)
    // =========================================================================
    if n_qubits > 1 {
        qasm.push_str("// Layer 3: CNOT entanglement - create feature correlations\n");
        for i in 0..(n_qubits - 1) {
            // CNOT from qubit i to qubit i+1
            qasm.push_str(&format!("cx q[{}],q[{}];\n", i, i + 1));
        }
        qasm.push_str("\n");
    }

    // =========================================================================
    // Layer 4: Second RZ rotation (deeper encoding)
    // =========================================================================
    qasm.push_str("// Layer 4: Second RZ rotation - deeper encoding\n");
    for (i, &x) in data.iter().enumerate() {
        qasm.push_str(&format!("rz({:.6}) q[{}];\n", x * 2.0, i));
    }
    qasm.push_str("\n");

    // =========================================================================
    // Optional: Measurement (uncomment to measure)
    // =========================================================================
    qasm.push_str("// Uncomment below to add measurements:\n");
    for i in 0..n_qubits {
        qasm.push_str(&format!("// measure q[{}] -> c[{}];\n", i, i));
    }

    qasm
}

/// Saves QASM code to a file.
///
/// # Arguments
/// * `qasm` - The QASM string to save
/// * `filename` - Output file path (e.g., "feature_map.qasm")
///
/// # Returns
/// Result indicating success or error
pub fn save_qasm_to_file(qasm: &str, filename: &str) -> std::io::Result<()> {
    let path = Path::new(filename);
    let mut file = File::create(path)?;
    file.write_all(qasm.as_bytes())?;
    println!("✅ QASM saved to: {}", filename);
    Ok(())
}

/// Serializable version of QSVM model for JSON export
#[derive(Serialize, Deserialize, Debug)]
pub struct QSVMExport {
    /// Model metadata
    pub model_name: String,
    pub n_qubits: usize,
    pub n_support_vectors: usize,

    /// Support vectors (flattened 2D array)
    pub support_vectors: Vec<f64>,
    pub support_vectors_shape: (usize, usize),

    /// Labels of support vectors
    pub support_labels: Vec<f64>,

    /// Alpha weights
    pub alpha: Vec<f64>,

    /// Bias term
    pub bias: f64,
}

impl QSVMExport {
    /// Creates an exportable model from a trained QSVM
    pub fn from_qsvm(model: &QSVM) -> Self {
        let n_svs = model.support_vectors.nrows();
        let n_features = model.support_vectors.ncols();

        QSVMExport {
            model_name: "QSVM Bot Detector".to_string(),
            n_qubits: n_features,
            n_support_vectors: n_svs,
            support_vectors: model.support_vectors.iter().cloned().collect(),
            support_vectors_shape: (n_svs, n_features),
            support_labels: model.support_labels.iter().cloned().collect(),
            alpha: model.alpha.iter().cloned().collect(),
            bias: model.bias,
        }
    }

    /// Saves the model to a JSON file
    pub fn save_to_json(&self, filename: &str) -> std::io::Result<()> {
        let json = serde_json::to_string_pretty(self)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

        let path = Path::new(filename);
        let mut file = File::create(path)?;
        file.write_all(json.as_bytes())?;

        println!("✅ Model saved to: {}", filename);
        Ok(())
    }

    /// Loads a model from a JSON file
    pub fn load_from_json(filename: &str) -> std::io::Result<Self> {
        let path = Path::new(filename);
        let file = File::open(path)?;
        let model: QSVMExport = serde_json::from_reader(file)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

        println!("✅ Model loaded from: {}", filename);
        Ok(model)
    }
}

/// Generates a Python script to load and run the QASM in Qiskit
pub fn generate_qiskit_loader() -> String {
    r#"#!/usr/bin/env python3
"""
Qiskit loader for QSVM Feature Map
Generated by quantum-simulation-qsvm (Rust)

Usage:
    1. Install qiskit: pip install qiskit qiskit-aer
    2. Run this script: python load_qasm.py
"""

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

# Load the QASM file generated by Rust
circuit = QuantumCircuit.from_qasm_file("feature_map.qasm")

# Print circuit info
print(f"Circuit has {circuit.num_qubits} qubits")
print("\nCircuit diagram:")
print(circuit.draw())

# Simulate the circuit
simulator = AerSimulator()
circuit.save_statevector()
job = simulator.run(circuit)
result = job.result()
statevector = result.get_statevector()

print(f"\nStatevector (first 8 amplitudes):")
for i, amp in enumerate(statevector[:8]):
    print(f"  |{i:04b}⟩: {amp:.4f}")

# To run on real IBM hardware:
# from qiskit_ibm_runtime import QiskitRuntimeService
# service = QiskitRuntimeService()
# backend = service.backend("ibm_brisbane")
# job = backend.run(circuit)
"#
    .to_string()
}

// =============================================================================
// TESTS
// =============================================================================
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_qasm() {
        let data = vec![0.5, 1.0, 1.5, 2.0];
        let qasm = generate_qasm(&data);

        // Check header
        assert!(qasm.contains("OPENQASM 2.0"));
        assert!(qasm.contains("include \"qelib1.inc\""));

        // Check registers
        assert!(qasm.contains("qreg q[4]"));
        assert!(qasm.contains("creg c[4]"));

        // Check Hadamards
        assert!(qasm.contains("h q[0]"));
        assert!(qasm.contains("h q[3]"));

        // Check RZ gates
        assert!(qasm.contains("rz(0.500000) q[0]"));
        assert!(qasm.contains("rz(2.000000) q[3]"));

        // Check CNOTs
        assert!(qasm.contains("cx q[0],q[1]"));
        assert!(qasm.contains("cx q[2],q[3]"));
    }

    #[test]
    fn test_qasm_valid_format() {
        let data = vec![0.1, 0.2];
        let qasm = generate_qasm(&data);

        // Each line should end with semicolon (except comments)
        for line in qasm.lines() {
            let trimmed = line.trim();
            if !trimmed.is_empty() && !trimmed.starts_with("//") {
                assert!(
                    trimmed.ends_with(';')
                        || trimmed.starts_with("OPENQASM")
                        || trimmed.starts_with("include"),
                    "Line should end with semicolon: {}",
                    line
                );
            }
        }
    }
}
